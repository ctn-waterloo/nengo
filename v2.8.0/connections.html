

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>Connections in depth &#8212; Nengo core 2.8.0 docs</title>
    <link rel="stylesheet" href="_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GT8XEDLTMJ"></script>
<script>
 window.dataLayer = window.dataLayer || [];
 function gtag(){dataLayer.push(arguments);}
 gtag('js', new Date());
 gtag('config', 'G-GT8XEDLTMJ');
</script>
<!-- End Google tag (gtag.js) -->

<!-- Matomo -->
<script>
 var _paq = window._paq = window._paq || [];
 _paq.push(["setDocumentTitle", document.domain + "/" + document.title]);
 _paq.push(["setCookieDomain", "*.appliedbrainresearch.com"]);
 _paq.push(["setDomains", ["*.appliedbrainresearch.com","*.edge.nengo.ai","*.forum.nengo.ai","*.labs.nengo.ai","*.nengo.ai"]]);
 _paq.push(["enableCrossDomainLinking"]);
 _paq.push(["setDoNotTrack", true]);
 _paq.push(['trackPageView']);
 _paq.push(['enableLinkTracking']);
 (function() {
   var u="https://appliedbrainresearch.matomo.cloud/";
   _paq.push(['setTrackerUrl', u+'matomo.php']);
   _paq.push(['setSiteId', '3']);
   var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
   g.async=true; g.src='//cdn.matomo.cloud/appliedbrainresearch.matomo.cloud/matomo.js'; s.parentNode.insertBefore(g,s);
 })();
</script>
<!-- End Matomo Code -->
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Nengo configuration" href="nengorc.html" />
    <link rel="prev" title="Advanced topics" href="advanced.html" />
<link rel="stylesheet" type="text/css" href="_static/custom.css">


  
   

  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="nengorc.html" title="Nengo configuration"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Advanced topics"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Nengo core 2.8.0 docs</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="user_guide.html" >User guide</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="advanced.html" accesskey="U">Advanced topics</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
        <a href="
    index.html" class="text-logo">Nengo core 2.8</a>
        <div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Table Of Contents</h2>
  </div>
  <div class="sidebar-toc">
    
    
      <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="user_guide.html">User guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="frontend_api.html">Nengo frontend API</a></li>
<li class="toctree-l2"><a class="reference internal" href="config.html">Setting parameters with Configs</a></li>
<li class="toctree-l2"><a class="reference internal" href="networks.html">Reusable networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="spa.html">Semantic Pointer Architecture</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="advanced.html">Advanced topics</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Connections in depth</a></li>
<li class="toctree-l3"><a class="reference internal" href="nengorc.html">Nengo configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="improving_performance.html">Improving performance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="backend_api.html">Nengo backend API</a></li>
<li class="toctree-l2"><a class="reference internal" href="changelog.html">Release History</a></li>
<li class="toctree-l2"><a class="reference internal" href="history.html">Nengo history</a></li>
<li class="toctree-l2"><a class="reference internal" href="converting.html">Converting from Nengo 1.4 to Nengo 2.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to Nengo</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.nengo.ai/projects.html">Nengo ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">Nengo license</a></li>
</ul>

    
  </div>
</div>
        
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
    </div>
  </div>
        <div id="right-column">
          
  <div class="header">
    
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="index.html">Docs</a></li>
              
                <li><a href="user_guide.html">User guide</a></li>
              
                <li><a href="advanced.html">Advanced topics</a></li>
              
              <li>Connections in depth</li>
            </ol>
          </div>
          
    
  </div>

          <div class="document clearer body">
            
  <div class="section" id="connections-in-depth">
<h1>Connections in depth<a class="headerlink" href="#connections-in-depth" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="frontend_api.html#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal"><span class="pre">Connection</span></code></a> object encapsulates different behaviors
depending on the attributes of the connection.
It can be helpful in debugging network behavior
to know what is happening under the hood
for different types of connections.</p>
<p>The biggest determiner of what happens
in a connection is the <code class="docutils literal"><span class="pre">pre</span></code> object.
When the <code class="docutils literal"><span class="pre">pre</span></code> object is an <a class="reference internal" href="frontend_api.html#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal"><span class="pre">Ensemble</span></code></a>
with a neuron type other than <a class="reference internal" href="frontend_api.html#nengo.Direct" title="nengo.Direct"><code class="xref py py-obj docutils literal"><span class="pre">Direct</span></code></a>,
Nengo will create a decoded connection.
When the <code class="docutils literal"><span class="pre">pre</span></code> object is anything else,
Nengo will create a direct connection.</p>
<p>The <code class="docutils literal"><span class="pre">post</span></code> object
is only used to determine
which signal will receive the data
produced by the connection.
If you’re not sure what your connection
is doing, interrogate the <code class="docutils literal"><span class="pre">pre</span></code> object first.</p>
<div class="section" id="decoded-connections">
<h2>Decoded connections<a class="headerlink" href="#decoded-connections" title="Permalink to this headline">¶</a></h2>
<p>Decoded connections are any connection
<strong>from an ensemble to any other object</strong>.
The following are all examples of decoded connections:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">ens1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">size_in</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ens2</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Ensemble to ensemble</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">)</span>
    <span class="c1"># Ensemble slice to node</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ens1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
    <span class="c1"># Ensemble to neurons slice</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="o">.</span><span class="n">neurons</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>The important thing about decoded connections
is that they do not directly compute the
<code class="docutils literal"><span class="pre">function</span></code> defined for that connection
(keeping in mind that passing in no function
is equivalent to passing in the identity function).
Instead, the function is approximated
by solving for a set of decoding weights.
The output of a decoded connection
is the sum of the pre ensemble’s neural activity
weighted by the decoding weights
solved for in the build process.</p>
<p>Mathematically, you can think of a decoded connection
as implementing the following equation:</p>
<div class="math">
\[\mathbf{y}(t) = \sum_{i=0}^n \mathbf{d}^{f}_i a_i(x(t))\]</div>
<p>where</p>
<ul class="simple">
<li><span class="math">\(\mathbf{y}(t)\)</span> is the output of the connection at time <span class="math">\(t\)</span>,</li>
<li><span class="math">\(n\)</span> is the number of neurons in the pre ensemble</li>
<li><span class="math">\(\mathbf{d}^{f}_i\)</span> is the decoding weight associated
with neuron <span class="math">\(i\)</span> given the function <span class="math">\(f\)</span>,</li>
<li><span class="math">\(a_i(x(t))\)</span> is the activity of neuron <span class="math">\(i\)</span> given
<span class="math">\(x(t)\)</span>, the input at time <span class="math">\(t\)</span>.</li>
</ul>
<p>Note that the length of the <span class="math">\(\mathbf{d}\)</span> and <span class="math">\(\mathbf{y}\)</span> vectors
is the same, and is specified by the dimensionality of
the output of the function <span class="math">\(f\)</span> when applied to input <span class="math">\(x\)</span>.</p>
<p>While the equation above is straightforward,
there are several important implications
that one should keep in mind when using decoded connections.</p>
<ul>
<li><p class="first">Decoders will be automatically solved for in the build process.</p>
<p>Solving for decoders makes up the majority of build time,
so if building your networks takes a long time,
look at your decoded connections and
try lowering the number of neurons
or using different <a class="reference internal" href="frontend_api.html#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal"><span class="pre">Solver</span></code></a> types.</p>
</li>
<li><p class="first">The function passed to the connection
is used to determine decoders.
It will never be run during the simulation.</p>
<p>When you define a function in a node,
it will be execute on every simulation timestep.
That may lead you to think that the function
passed to a connection is executed on every timestep,
but that is <em>not</em> the case for decoded connections.
The function passed to the connection will be executed
in the decoder solving process determine an error
to minimize, but never during the simulation.</p>
</li>
<li><p class="first">The characteristics of the <code class="docutils literal"><span class="pre">pre</span></code> ensemble
are critically important to performance.</p>
<p>If you determine that your decoded connection
is not approximating the desired function well,
examine the <code class="docutils literal"><span class="pre">pre</span></code> ensemble.
The decoded value depends on the activity
of the <code class="docutils literal"><span class="pre">pre</span></code> ensemble;
does it represent its input reliably?
If not, then a function of that input
cannot be well approximated.
If you think that your function may be incorrect,
switch the <code class="docutils literal"><span class="pre">pre</span></code> ensemble to use
the <a class="reference internal" href="frontend_api.html#nengo.Direct" title="nengo.Direct"><code class="xref py py-obj docutils literal"><span class="pre">Direct</span></code></a> neuron type,
which does not use decoders.
If that function looks correct,
move on to a simpler neuron type
like <a class="reference internal" href="frontend_api.html#nengo.RectifiedLinear" title="nengo.RectifiedLinear"><code class="xref py py-obj docutils literal"><span class="pre">RectifiedLinear</span></code></a> until you
can determine why your function is not
being approximated well.</p>
<p>Concrete examples of how the properties of <code class="docutils literal"><span class="pre">pre</span></code> ensemble influence the
desired function can be found in <a class="footnote-reference" href="#id4" id="id1">[1]</a>, <a class="footnote-reference" href="#id5" id="id2">[2]</a>.</p>
</li>
</ul>
</div>
<div class="section" id="direct-connections">
<h2>Direct connections<a class="headerlink" href="#direct-connections" title="Permalink to this headline">¶</a></h2>
<p>Any connection that is not a decoded connection
is a direct connection.</p>
<p>For simplicity and consistency,
Nengo exposes the same interface
for decoded and direct connections.
In all cases, data from the <code class="docutils literal"><span class="pre">pre</span></code> object
is sent to the <code class="docutils literal"><span class="pre">post</span></code> object,
with an optional <code class="docutils literal"><span class="pre">synapse</span></code> filter.
In decoded connections,
weights are automatically determined
through decoder solving.
In direct connections,
weights can be manually specified
through the <code class="docutils literal"><span class="pre">transform</span></code> argument. <a class="footnote-reference" href="#id6" id="id3">[3]</a></p>
<p>The most common example of a direct connection
is a neuron-to-neuron connection.
These connections are the types of connections
you see in most neural simulators,
and can be used to reproduce networks
written in other simulators like
<a class="reference external" href="http://briansimulator.org/">Brian</a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">ens1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ens2</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Neuron to neuron</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">ens2</span><span class="o">.</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">ens1</span><span class="o">.</span><span class="n">n_neurons</span><span class="p">))</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ens1</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="n">ens2</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that it does not matter that the dimensionality of <code class="docutils literal"><span class="pre">ens1</span></code>
does not match the dimensionality of <code class="docutils literal"><span class="pre">ens2</span></code>.
It only matters that the <code class="docutils literal"><span class="pre">transform</span></code>
is of the correct shape,
which in the case of neuron-to-neuron connections
is <code class="docutils literal"><span class="pre">(post.n_neurons,</span> <span class="pre">pre.n_neurons)</span></code>.</p>
<p>In the vast majority of cases,
the above description is all you need to know.
Below we give some additional examples,
focusing on situations that differ from the description above.</p>
<div class="section" id="nodes-and-direct-ensembles">
<h3>Nodes and <a class="reference internal" href="frontend_api.html#nengo.Direct" title="nengo.Direct"><code class="xref py py-obj docutils literal"><span class="pre">Direct</span></code></a> ensembles<a class="headerlink" href="#nodes-and-direct-ensembles" title="Permalink to this headline">¶</a></h3>
<p>In connections from nodes and ensembles
using the <a class="reference internal" href="frontend_api.html#nengo.Direct" title="nengo.Direct"><code class="xref py py-obj docutils literal"><span class="pre">Direct</span></code></a> neuron type,
the <code class="docutils literal"><span class="pre">function</span></code> argument is valid
and will result in the function being applied
to the input on every timestep.
This is in direct contrast to decoded connections,
in which the function is executed
during the build process and <em>not</em> during the simulation.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ens1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">neuron_type</span><span class="o">=</span><span class="n">nengo</span><span class="o">.</span><span class="n">Direct</span><span class="p">())</span>
    <span class="n">ens2</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Node to LIF ensemble</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ens2</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Direct ensemble to LIF ensemble</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="passthrough-nodes">
<h3>Passthrough nodes<a class="headerlink" href="#passthrough-nodes" title="Permalink to this headline">¶</a></h3>
<p>When creating large networks,
it is often helpful to use passthrough nodes
to route signals from place to place
without introducing unnecessary ensembles.
For example, the <a class="reference internal" href="networks.html#nengo.networks.EnsembleArray" title="nengo.networks.EnsembleArray"><code class="xref py py-obj docutils literal"><span class="pre">EnsembleArray</span></code></a> network
is often used to represent a high-dimensional vector
with many lower-dimensional ensemble.
The high-dimensional vector is still available
as <code class="xref py py-obj docutils literal"><span class="pre">EnsembleArray.output</span></code> through the use
of a passthrough node that collects the output
of all the lower-dimensional ensembles.</p>
<p>Unlike other types of nodes,
we explicitly disable the <code class="docutils literal"><span class="pre">function</span></code> argument
when connecting from passthrough nodes.
The reason for this is to ensure that users know
they are making a direct connection
and not a decoded connection.
The output of a network like <a class="reference internal" href="networks.html#nengo.networks.EnsembleArray" title="nengo.networks.EnsembleArray"><code class="xref py py-obj docutils literal"><span class="pre">EnsembleArray</span></code></a>
can usually be treated the same way
as the output of an <a class="reference internal" href="frontend_api.html#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal"><span class="pre">Ensemble</span></code></a>,
except for the case of applying a function
to the output,
since decoders are not used to approximate
the function in the case of networks
using passthrough nodes.</p>
<p>As an example,
consider using an <a class="reference internal" href="networks.html#nengo.networks.EnsembleArray" title="nengo.networks.EnsembleArray"><code class="xref py py-obj docutils literal"><span class="pre">EnsembleArray</span></code></a> to compute a product:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">ea</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">networks</span><span class="o">.</span><span class="n">EnsembleArray</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">product</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Passthrough node to ensemble -- raises error</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ea</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>If this example did not raise an error,
the product would be computed nearly perfectly,
despite the fact that that computation
is impossible to decode from the ensembles
of the ensemble array.
Consider that the product
requires information from both dimensions of the signal
(i.e., the dimensions interact nonlinearly).
In order for nonlinearities to be decoded,
some neurons must encode information from
the nonlinearly-interacting dimensions.
Since the ensemble array represents each dimension independently,
no neurons will encode information from multiple dimensions,
and therefore the product cannot be approximated
by the ensemble array.</p>
<p>If you are aware that the function
will not be approximated but directly computed,
and you desire this behavior,
you can enable it by modifying the node so that it is
no longer a passthrough node,
but instead computes the identity function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">ea</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">networks</span><span class="o">.</span><span class="n">EnsembleArray</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">product</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Make the node non-passthrough</span>
    <span class="n">ea</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
    <span class="c1"># Node to ensemble -- no error</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ea</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>If you’re designing networks
that may have arbitrary function
applied to the output,
you should implement a way to make
decoded connections from the ensembles
in your network.
See the <a class="reference internal" href="networks.html#nengo.networks.EnsembleArray.add_output" title="nengo.networks.EnsembleArray.add_output"><code class="xref py py-obj docutils literal"><span class="pre">EnsembleArray.add_output</span></code></a> method
for an example of how that might be implemented.</p>
</div>
<div class="section" id="neuron-to-ensemble-connections">
<h3>Neuron-to-ensemble connections<a class="headerlink" href="#neuron-to-ensemble-connections" title="Permalink to this headline">¶</a></h3>
<p>As noted above,
a decoded connection is implemented by
solving for a set of decoding weights
and then weighting a sum of activities by those decoders.
If you already know the decoding weights
you want to use on a connection,
then you can skip the decoder solving step
by using a direct connection
from the neurons of an ensemble to another object.</p>
<p>In the example below,
we make two equivalent connections,
one using a decoded connection
and one using a direct connection:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">ens1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ens2</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Decoded ensemble to ensemble connection</span>
    <span class="n">conn1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ens1</span><span class="p">,</span> <span class="n">ens2</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>

<span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="k">as</span> <span class="n">sim</span><span class="p">:</span>
    <span class="n">decoders</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">conn1</span><span class="p">]</span><span class="o">.</span><span class="n">weights</span>

<span class="k">with</span> <span class="n">net</span><span class="p">:</span>
    <span class="c1"># Direct neurons to ensemble connection</span>
    <span class="n">conn2</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ens1</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="n">ens2</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">decoders</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above example, the shape of <code class="docutils literal"><span class="pre">decoders</span></code> is <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">20)</span></code>.
If you run this example and probe the output of <code class="docutils literal"><span class="pre">conn1</span></code>
and <code class="docutils literal"><span class="pre">conn2</span></code>, you will see that their output is the same
(as long as a seed is set on <code class="docutils literal"><span class="pre">ens1</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">probe1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">conn1</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="n">probe2</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">conn2</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="k">as</span> <span class="n">sim</span><span class="p">:</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">probe1</span><span class="p">],</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">probe2</span><span class="p">])</span>
</pre></div>
</div>
<p>Both <code class="docutils literal"><span class="pre">conn1</span></code> and <code class="docutils literal"><span class="pre">conn2</span></code> can have learning rules applied,
so this type of direct connection can be useful
when saving the weights in a learning network
and loading it up in the future.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Gosmann, Jan. Precise multiplications with the NEF.
Waterloo, Ontario, Canada: University of Waterloo; 2015.
Available from: <a class="reference external" href="https://zenodo.org/record/35680">https://zenodo.org/record/35680</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Gosmann, Jan, and Chris Eliasmith. “Optimizing Semantic Pointer
Representations for Symbol-Like Processing in Spiking Neural Networks.”
PLoS ONE 11, no. 2 (February 22, 2016): e0149928.
<a class="reference external" href="http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0149928">doi:10.1371/journal.pone.0149928</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Note that decoded connections
also accept the <code class="docutils literal"><span class="pre">transform</span></code> argument.
In the case of decoded connections,
the <code class="docutils literal"><span class="pre">transform</span></code> is a linear operation
that is applied after the function
is applied to the input.
In most cases, slicing the input
or including the transform
in the function is recommended.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="advanced.html" title="previous chapter (use the left arrow)">Advanced topics</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="nengorc.html" title="next chapter (use the right arrow)">Nengo configuration</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="nengorc.html" title="Nengo configuration"
             >next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Advanced topics"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Nengo core 2.8.0 docs</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="user_guide.html" >User guide</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="advanced.html" >Advanced topics</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2013-2017, Applied Brain Research. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>