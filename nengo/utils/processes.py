from __future__ import absolute_import
import numpy as np

from nengo.utils.distributions import Gaussian


class StochasticProcess(object):
    """A base class for stochastic processes.

    A stochastic process is similar to a distribution, but differs in two ways.

    1. The ``sample`` function accepts a ``dt`` argument as the first
       positional argument, and zero or more or more arguments representing
       the state of the process as the last arguments.
    2. The initial state of the process can be generated by calling the
       ``initial_state`` function. This will return a dictionary that can be
       unpacked in the ``sample`` function to track the state over multiple
       calls to ``sample``.

    Examples
    --------

    All stochastic processes can be used in the following way.

    >>> dt = 0.001
    >>> d = 1
    >>> n_samples = 10
    >>> process = StochasticProcess()
    >>> state = process.initial_state(dt, d)
    >>> samples = process.sample(dt, n_samples, d=d, **state)

    This is not required, however; state can be generated manually and passed
    to the sample function. Processes that are known to not require state can
    be used without calling ``initial_state`` or passing in state.
    """

    def initial_state(self, dt, d=None, rng=np.random):
        """Provides the initial state for the process.

        Subclasses should override this if the ``sample`` function requires
        some state to be tracked across ``sample`` calls. The state should be
        modified in-place.

        Returns
        -------
        dict
            A dictionary mapping from strings to ndarrays, corresponding to
            argument names and initial states for those arguments.
        """
        return {}

    def sample(self, dt, n, d=None, rng=np.random):
        """Samples the process and advances the time.

        Parameters
        ----------
        dt : float
            Timestep for each sample.
        n : int
            Number samples to take.
        d : int or None, optional
            The number of dimensions to return. If this is an int, the return
            value will be of shape ``(n, d)``. If None (default), the return
            value will be of shape ``(n,)``.
        rng : RandomState, optional
            Random number generator state.

        Returns
        -------
        ndarray
            Samples as a 1d or 2d array depending on ``d``. The second
            dimension enumerates the dimensions of the process.
        """
        raise NotImplementedError(
            "StochasticProcesses should implement sample.")


class SampledProcess(StochasticProcess):
    """A time-invariant process based on a distribution.

    At each time point, an independent sample of a probability distribution
    function is taken.

    Parameters
    ----------
    dist : :class:`Distribution`
        Probability distribution to sample from.
    """
    def __init__(self, dist):
        self.dist = dist

    def sample(self, dt, n, d=None, rng=np.random):
        # FIXME correct for dt here?
        return self.dist.sample(n, d, rng=rng)


class MarkovProcess(StochasticProcess):
    """A Markov process; each new sample only depends on the current state.

    Parameters
    ----------
    dist : :class:`Distribution`
        Probability distribution to sample from in each timestep.
    initial_state : 1d array, optional
        The initial state. The length has to match `dimensions`. If not given,
        an initial state of all zeros will be assumed.
    """
    def __init__(self, dist, initial_state=None):
        self.dist = dist
        self._initial_state = initial_state

    def initial_state(self, dt, d=None, rng=np.random):
        state = (np.zeros(d) if self._initial_state is None
                 else np.array(self._initial_state))
        d = 1 if d is None else d
        if state.size != d:
            raise ValueError("'initial_state' is %dD; should be %dD" %
                             (state.size, d))
        return {'state': state}

    def sample(self, dt, n, state, d=None, rng=np.random):
        samples = state + np.cumsum(
            self.dist.sample(n, d, rng=rng) * np.sqrt(dt), axis=0)
        state[...] = samples[-1]
        return samples


class BrownNoise(MarkovProcess):
    """A Brown noise process; i.e., a Weiner process."""
    def __init__(self, initial_state=None):
        super(BrownNoise, self).__init__(Gaussian(0, 1.), initial_state)


class WhiteNoise(StochasticProcess):
    """A low-pass filtered Gaussian white noise process.

    Parameters
    ----------
    duration : float
        A white noise signal for this duration will be generated; sampling
        after this duration will repeat from the beginning of the signal.
    rms : float, optional
        The root mean square power of the filtered signal. Default: 0.5.
    high : float or None, optional
        The cut-off frequency of the low-pass filter, in Hz.
        If ``None``, no filtering will be done.
    dt : float or None, optional
        The timestep that will be used when sampling this process.
        This is mostly useful when generating the signal to be passed in
        manually; the dt used to generate the signal should be specified here.
    """
    def __init__(self, duration, rms=0.5, high=None, dt=None):
        self.duration = duration
        self.rms = rms
        self.high = high
        self.dt = dt

    def initial_state(self, dt, d, rng=np.random):
        self.dt = dt
        n_coefficients = int(np.ceil(self.duration / dt / 2.))
        shape = (d, n_coefficients + 1)
        sigma = self.rms * np.sqrt(0.5)
        coefficients = 1j * rng.normal(0., sigma, size=shape)
        coefficients += rng.normal(0., sigma, size=shape)
        coefficients[:, 0] = 0.
        coefficients[:, -1].imag = 0.
        if self.high is not None:
            set_to_zero = np.fft.rfftfreq(2 * n_coefficients, d=dt) > self.high
            coefficients[:, set_to_zero] = 0.
            power_correction = np.sqrt(
                1. - np.sum(set_to_zero, dtype=float) / n_coefficients)
            if power_correction > 0.:
                coefficients /= power_correction
        coefficients *= np.sqrt(2 * n_coefficients)

        return {'t': np.array(0),
                'signal': np.fft.irfft(coefficients, axis=1)}

    def sample(self, dt, n, t, signal, d=None, rng=np.random):
        assert self.dt == dt, "Sample dt should match dt of signal."
        if d is not None and signal.shape[0] < d:
            raise ValueError(
                "Cannot generate {0} dimensions; signal only contains {1}."
                "".format(1 if d is None else d, signal.shape[0]))
        ts = (np.arange(n) + t) % signal.shape[1]
        t[...] = ts[-1] + 1
        samples = np.take(signal, ts, axis=1)
        if d is None:
            return samples[0]
        else:
            return samples[:d].T
